<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Roche's Blog</title>
    <description>A la guerre à guerre</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 14 Dec 2018 17:19:18 +0800</pubDate>
    <lastBuildDate>Fri, 14 Dec 2018 17:19:18 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Meaningless Push 1</title>
        <description>&lt;h1 id=&quot;bsd内核服务器&quot;&gt;BSD内核服务器&lt;/h1&gt;

&lt;p&gt;最近在写一个BSD内核内的HTTP服务器&lt;br /&gt;
练手用&lt;br /&gt;
&lt;del&gt;随时都可能弃坑&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/roche-k/Tinyhttpd&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;最近的一些反馈&quot;&gt;最近的一些反馈&lt;/h1&gt;

&lt;p&gt;最近收到一些联络&lt;br /&gt;
认为使用推送中的代码无法达到预期的效果&lt;/p&gt;

&lt;p&gt;比如&lt;br /&gt;
之前写的加速判定字符串分类的推送&lt;/p&gt;

&lt;p&gt;这里说明下～&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优化这个事情，有些普遍适用的部分，你在使用代码的过程中可能没有加入&lt;/li&gt;
  &lt;li&gt;有些优化的方法，由于保密协议的问题，不好说出来&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;懒的写&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就酱&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Nov 2018 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/15/MeaninglessPush1/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/15/MeaninglessPush1/</guid>
        
        <category>Meaningless</category>
        
        
      </item>
    
      <item>
        <title>Build a simple chat bot</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;del&gt;这次用google翻译，应该会好一点了&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;这次的算法和模型都是已知的一些东西&lt;br /&gt;
除了数据，没有什么创新点&lt;br /&gt;
尽量写短点&lt;/p&gt;

&lt;h1 id=&quot;模型&quot;&gt;模型&lt;/h1&gt;

&lt;p&gt;聊天机器人的原理和模型，这个已经被探讨过很多遍了&lt;br /&gt;
我觉得没有再重新复制粘贴，加几句当自己的理解的必要&lt;/p&gt;

&lt;p&gt;如果有想要了解的，左传搜索chat bot&lt;/p&gt;

&lt;h1 id=&quot;数据&quot;&gt;数据&lt;/h1&gt;

&lt;p&gt;这次的数据从Galgame里获取&lt;br /&gt;
没有错  G A L&lt;/p&gt;

&lt;p&gt;因为galgame有很多做移植的人员&lt;br /&gt;
移植后的游戏，对话数据一般会被保存在固定格式的脚本里&lt;/p&gt;

&lt;p&gt;虽然脚本有很多内容&lt;br /&gt;
&lt;del&gt;我也没研究过这些内容有什么作用&lt;/del&gt;&lt;br /&gt;
但一般来说，对话 / 人物都很好提取&lt;/p&gt;

&lt;p&gt;比如这个&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    L1 +++$+++ u0 +++$+++ m0 +++$+++ 【女招待】 +++$+++ 「欢迎光临。您远道而来，想必一定很累了吧？」
    L2 +++$+++ u1 +++$+++ m0 +++$+++ 【深见】 +++$+++ 「不会……空气也清爽，也让我焕然一新呢」
    L3 +++$+++ u0 +++$+++ m0 +++$+++ 【女招待】 +++$+++ 「是吗。那真是太好了」
    L4 +++$+++ u0 +++$+++ m0 +++$+++ 【女招待】 +++$+++ 「您的包我先代为保管了。那么，请到里面来」
    L5 +++$+++ u1 +++$+++ m0 +++$+++ 【深见】 +++$+++ 「谢谢」
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;赞美汉化组～～～～&lt;/p&gt;

&lt;h1 id=&quot;训练&quot;&gt;训练&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用CPU训练，大约30此迭代后完成   
~~CPU很满~~

然后就可以使用进行聊天了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;结语&quot;&gt;结语&lt;/h1&gt;

&lt;p&gt;撸猫撸猫&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Nov 2018 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/01/BuildASimpleChatBot/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/01/BuildASimpleChatBot/</guid>
        
        <category>RNN</category>
        
        
      </item>
    
      <item>
        <title>Using CNN to identify SQL and XSS 2</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;之前写过这个&lt;/p&gt;

&lt;p&gt;使用CNN做SQL和XSS的识别&lt;/p&gt;

&lt;p&gt;在前一个post里，模型的推理速度大约是100us。&lt;br /&gt;
在这一篇post里，我将对这个模型做一些改进，让这个模型的预测速度更快一点。&lt;/p&gt;

&lt;h1 id=&quot;实际的步骤&quot;&gt;实际的步骤&lt;/h1&gt;

&lt;p&gt;首先，我是利用一个类似与word2vec的思路，将数据转化为模型输入的数据的。&lt;br /&gt;
总体的算法是一个循环查找匹配的动作。&lt;br /&gt;
这个过程基于数据量的大小，有很多可以作为优化选项的算法。&lt;/p&gt;

&lt;p&gt;这里，随手利用一个～
不做主体来说&lt;/p&gt;

&lt;p&gt;然后，如果仔细观察下CPU利用率的话，&lt;br /&gt;
可以发现，在循环跑session的过程中，CPU并没有拉满。
可见在session运行中，有一些动作会使CPU空转，或者本身预测的过程，CPU就不容易拉起来。&lt;/p&gt;

&lt;p&gt;这一点，可以启动多个session，并行处理数据&lt;/p&gt;

&lt;p&gt;首先，定义总循环量，和单线程循环量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define TRUE_LOOP_TIME 100000
#define LOOP_TIMES (TRUE_LOOP_TIME / 8)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我是使用笔记本的i7 4700mq在跑，所以这里定义8条线程&lt;/p&gt;

&lt;p&gt;然后这里是线程共有的信息&lt;br /&gt;
需要的判定字符串，以及作为最后统计使用的最大时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const char* input_line;
long long total_time;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后定义线程应该做的事情&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;读取model，载入&lt;/li&gt;
  &lt;li&gt;循环开始&lt;/li&gt;
  &lt;li&gt;填充tensor&lt;/li&gt;
  &lt;li&gt;跑session&lt;/li&gt;
  &lt;li&gt;循环结束&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记录时间&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void TF_Thraed(void)
{
    int i;
    struct timeval start, end;

    model_t* model = TF_LoadModel(&quot;frozen.pb&quot;);
    assert(model != NULL);
        
    gettimeofday( &amp;amp;start, NULL );
    for(i = 0; i &amp;lt; LOOP_TIMES; i ++) {
        if (!TF_FillTensor(model, input_line)) {
            puts(&quot;TF_FillTensor failed&quot;);
            return;
        }
        TF_RunModel(model);
    }
    gettimeofday( &amp;amp;end, NULL );

    total_time += ((end.tv_sec - start.tv_sec) * 1000000) + end.tv_usec - start.tv_usec;

    TF_FreeModel(model);
    pthread_detach(pthread_self());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对应，主线程这里需要做一些修改&lt;/p&gt;

&lt;p&gt;创建8条线程，并等待运行结束&lt;br /&gt;
计算出平均时间，打印出来&lt;/p&gt;

&lt;p&gt;这里是假设全线程会占用全部的性能。
线程扩充的时间需要平均被每条线程吃掉。
实际上，线程完成的速度会稍有区别，得到的平均时间会稍大。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int main(int argc, char const *argv[])
    {
        pthread_t tf_thread[8];
        double out_time;
        
        if (argc &amp;lt; 2 || !argv[1] ||!InitVocab()) {
            puts(&quot;No input&quot;);
            return 1;
        }
        input_line = argv[1];
        total_time = 0;

        pthread_create(&amp;amp;tf_thread[0], NULL, (void *)TF_Thraed, NULL);
        pthread_create(&amp;amp;tf_thread[1], NULL, (void *)TF_Thraed, NULL);
        pthread_create(&amp;amp;tf_thread[2], NULL, (void *)TF_Thraed, NULL);
        pthread_create(&amp;amp;tf_thread[3], NULL, (void *)TF_Thraed, NULL);
        pthread_create(&amp;amp;tf_thread[4], NULL, (void *)TF_Thraed, NULL);
        pthread_create(&amp;amp;tf_thread[5], NULL, (void *)TF_Thraed, NULL);
        pthread_create(&amp;amp;tf_thread[6], NULL, (void *)TF_Thraed, NULL);
        pthread_create(&amp;amp;tf_thread[7], NULL, (void *)TF_Thraed, NULL);

        pthread_join(tf_thread[7], NULL);

        sleep(2);
        out_time = (total_time / 8) / TRUE_LOOP_TIME;
        printf(&quot;max time = %f us\n&quot;, out_time);

        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还可以把线程对应CPU绑定，或者使用更好的线程同步的方法。
&lt;del&gt;post不想写这些&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;最后这里的平均计算时间为17微妙，比上一篇post，提高了6倍左右&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://roche-k.github.io/img/in-post/deep_learnig/2018-10-28-time.png&quot; alt=&quot;大概这样&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;结语&quot;&gt;结语&lt;/h1&gt;

&lt;p&gt;撸猫撸猫&lt;/p&gt;
</description>
        <pubDate>Sun, 28 Oct 2018 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/28/Using-CNNToIdentifySQLandXSS2-2019/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/28/Using-CNNToIdentifySQLandXSS2-2019/</guid>
        
        <category>CNN</category>
        
        
      </item>
    
      <item>
        <title>Using CNN to identify SQL and XSS</title>
        <description>&lt;p&gt;来篇正式点的Post吧&lt;br /&gt;
&lt;del&gt;燃燃燃然&lt;/del&gt;&lt;/p&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;最近在FreeBUF上看到这样一篇文章&lt;br /&gt;
&lt;a href=&quot;http://www.freebuf.com/articles/web/176709.html&quot;&gt;基于卷积神经网络的SQL注入检测&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我觉得CNN算法就其本身而言，应用与NLP是没有问题的。&lt;br /&gt;
但是这个检测率应该可以再提升一点。&lt;br /&gt;
因为SQL，XSS的注入方法，就语法上而言，比NLP要简单一些。&lt;/p&gt;

&lt;p&gt;还可以用C写一个检测程序。&lt;br /&gt;
这样就更容易让这个模型跑在实际的环境。&lt;/p&gt;

&lt;p&gt;而且，样本在送检之前，首先做了循环解码，再做归一化处理。&lt;br /&gt;
循环解码是需要的，但是归一化处理不一样。&lt;br /&gt;
安全性不论，每条数据先要跑正则再送检，这个效率要比传统的正则匹配法低一些。&lt;/p&gt;

&lt;p&gt;那么，让我在巨人的肩膀上，再做一些小改进。&lt;/p&gt;

&lt;h1 id=&quot;理论&quot;&gt;理论&lt;/h1&gt;

&lt;p&gt;对于通过CNN来做NLP处理的论文，国内外都可以找到很多。&lt;/p&gt;

&lt;p&gt;大致的原理是这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://roche-k.github.io/img/in-post/deep_learnig/2018-09-29-NLP-CNN.png&quot; alt=&quot;大概这样&quot; /&gt;&lt;/p&gt;

&lt;p&gt;句子-&amp;gt;词向量-&amp;gt;卷积层-&amp;gt;池化层-&amp;gt;链接层&lt;/p&gt;

&lt;p&gt;简单的说，就是把句子内的词转化为词向量，后面接单层的CNN。&lt;/p&gt;

&lt;h1 id=&quot;训练数据&quot;&gt;训练数据&lt;/h1&gt;

&lt;p&gt;首先，我们需要训练集，对照集，检测集
这个可以用github的一些数据。这里，就使用前一文中提到的数据集来检测。&lt;/p&gt;

&lt;p&gt;首先，循环读取每一条数据，对每条数据循环解码，打上标签，最后存档。&lt;br /&gt;
这里的UrlDecode()完成循环解码的功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for each_line in sql_file:
    str=UrlDecode(each_line)
    f.writelines('sql' + '\t' + str + '\n')
    count += 1
print(&quot;sql end at %d&quot; % count)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于训练集的第一条数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1%29%20AND%205628%3D4794  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;经过改写后，变成这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sql	1)and5628=4794
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;全部改写完成后，就可以用之前提到的模型训练了&lt;/p&gt;

&lt;p&gt;整个训练在6次迭代后完成。
这个是tensorboard的损失图像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://roche-k.github.io/img/in-post/deep_learnig/2018-09-29-tensotboard.png&quot; alt=&quot;大概这样&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后使用test集，可以达到99%以上的检测率。&lt;br /&gt;
混淆矩阵也很好看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://roche-k.github.io/img/in-post/deep_learnig/2018-09-29-matrix.png&quot; alt=&quot;大概这样&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;检测&quot;&gt;检测&lt;/h1&gt;

&lt;p&gt;之前说过，我们需要让这个模型能应用于实际的生产中。&lt;br /&gt;
那么，结合Tensorflow的C库，来写一个检测程序。&lt;br /&gt;
关于Tensorflow C库的使用，有很多现有的例子，就不多写了。&lt;/p&gt;

&lt;p&gt;大致的流程是这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, char* argv[])
{
    if (argc &amp;lt; 2) return 1;

    // pre load
    tf_model_t* model = LoadTFModel(&quot;./tf_model.pb&quot;);
    FillTensor(argv[1]);

    printf(&quot;Model Returns: %d\n&quot;, RunTFModel(model));

    FreeTFModel(model);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，就完成了使用C来检测注入的目标。&lt;br /&gt;
如果是需要重复的使用，可以在系统启动时调用LoadTFModel()，检测时只需调用FillTensor()和RunTFModel()即可。&lt;br /&gt;
可以省略掉加载的时间。&lt;br /&gt;
不用时调用FreeTFModel()清空资源。&lt;/p&gt;

&lt;p&gt;如果需要看下单次处理的速度之类。&lt;br /&gt;
在FillTensor()和RunTFModel()之间加个循环，前后记录时间，转double除一下就可以。&lt;/p&gt;

&lt;p&gt;我在i7-2700上跑了50万次，平均不到100微秒。&lt;br /&gt;
大致1秒1万-2万多次的样子。&lt;br /&gt;
有时间调调参，或者使用GPU的话应该会更高。&lt;/p&gt;

&lt;h1 id=&quot;结语&quot;&gt;结语&lt;/h1&gt;

&lt;p&gt;撸猫撸猫&lt;/p&gt;
</description>
        <pubDate>Sun, 30 Sep 2018 06:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/30/Using-CNNToIdentifySQLandXSS-2019/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/30/Using-CNNToIdentifySQLandXSS-2019/</guid>
        
        <category>CNN</category>
        
        
      </item>
    
      <item>
        <title>Cat Emperor 1</title>
        <description>&lt;p&gt;这次就写我家的猫皇吧&lt;br /&gt;
&lt;del&gt;才不是最近想要偷懒&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;最近合肥天气很热。&lt;br /&gt;
中午的时候猫皇张嘴哈气散热，就是类似狗散热的放方式。&lt;/p&gt;

&lt;p&gt;为了午睡一会。&lt;br /&gt;
顺带打开空调。
醒来时发现我家猫皇占领了空调出风口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://roche-k.github.io/img/in-post/cat/cat_001.png&quot; alt=&quot;大概这样&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且把这里当作领地了。&lt;/p&gt;

&lt;p&gt;试图赶走入侵者&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://roche-k.github.io/img/in-post/cat/cat_002.png&quot; alt=&quot;大概这样&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Aug 2018 04:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/11/CatEmperor1-2019/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/11/CatEmperor1-2019/</guid>
        
        <category>Cat</category>
        
        
      </item>
    
      <item>
        <title>A simple kernel-level server 2</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总觉得睡不着。&lt;br /&gt;
&lt;del&gt;那么就完善下之前写的通讯协议的rootkit下&lt;/del&gt;&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;上一次，最终我获取到了一个简单的把所有ICMP包置空的函数。&lt;br /&gt;
这个函数是不完美的。&lt;br /&gt;
但是至少开启了通信协议rootkit的头。&lt;/p&gt;

&lt;p&gt;那么，这次加装一些代码，让通信变得正常。&lt;br /&gt;
并且，为了以后加入一些简单多服务器功能，这次就用UDP的协议。&lt;/p&gt;

&lt;p&gt;之前说过，UDP长成这个样子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    .pr_type = 		    SOCK_DGRAM,
    .pr_domain = 		&amp;amp;inetdomain,
    .pr_protocol = 		IPPROTO_UDP,
    .pr_flags = 		PR_ATOMIC|PR_ADDR,
    .pr_input = 		udp_input,
    .pr_ctlinput = 		udp_ctlinput,
    .pr_ctloutput = 	ip_ctloutput,
    .pr_init = 		    udp_init,
    .pr_usrreqs = 		&amp;amp;udp_usrreqs
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么，要处理的就是这个函数指针 pr_input，这个原先存放的是udp_input，现在我要把它变成我自己的函数。&lt;/p&gt;

&lt;p&gt;首先，必不可少的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;case MOD_LOAD:
        /* Replace icmp_input with icmp_input_hook. */
        inetsw[ip_protox[IPPROTO_UDP]].pr_input = udp_input_hook;
        break;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;把pr_input拿下&lt;/p&gt;

&lt;p&gt;然后开设设计&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int
udp_input_hook(struct mbuf **mp, int *offp, int proto);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先，处理一下作为传参进入的iphlen长度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (iphlen &amp;gt; sizeof (struct ip)) {
	ip_stripoptions(m);
	iphlen = sizeof(struct ip);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了保证之后有UDP信息，UDP头和IP头的长度一定要保证下来。&lt;br /&gt;
剩余长度不满足UDP头的话，接下来就没办法处理了，所以这里把数据返回。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip = mtod(m, struct ip *);
if (m-&amp;gt;m_len &amp;lt; iphlen + sizeof(struct udphdr)) {
	if ((m = m_pullup(m, iphlen + sizeof(struct udphdr))) == NULL) {

		UDPSTAT_INC(udps_hdrops);
		return (IPPROTO_DONE);
	}
	ip = mtod(m, struct ip *);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，获取UDP头&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uh = (struct udphdr *)((caddr_t)ip + iphlen);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再剥离头&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m-&amp;gt;m_len -= iphlen + sizeof(struct udphdr);
m-&amp;gt;m_data += iphlen + sizeof(struct udphdr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，当前m_data的位置就是UDP数据区的位置了&lt;br /&gt;
把它打印出来&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printf(&quot;load=%s \n&quot;, m-&amp;gt;m_data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后把m_buf复原&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m-&amp;gt;m_len += iphlen + sizeof(struct udphdr);
m-&amp;gt;m_data -= iphlen + sizeof(struct udphdr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;返回给原处理函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return udp_input(mp, offp, proto);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，就完成了把每次pr_input都打印出的一个内核协议的rootkit。&lt;/p&gt;

&lt;p&gt;接下来，编译打入，就可以通过内核打印查看UDP内容了。&lt;br /&gt;
这样，就获得了一个非阻断性的内核层recive_from()。&lt;/p&gt;

&lt;p&gt;以后有时间再写吧。&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Jul 2018 09:45:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/26/SimpleKernelLevelServer2-2019/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/26/SimpleKernelLevelServer2-2019/</guid>
        
        <category>FreeBSD</category>
        
        <category>Kernel</category>
        
        <category>Server</category>
        
        
      </item>
    
      <item>
        <title>A simple kernel-level server 1</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;FreeBSD上的Rootkit终于写好啦～&lt;/p&gt;

&lt;p&gt;本来想着在一个不是特别熟的内核环境，写一个内核程序，会比较慢。 &lt;br /&gt;
&lt;del&gt;实际上是相当慢。&lt;/del&gt;&lt;br /&gt;
&lt;del&gt;vnode很烦，内存空间很烦&lt;/del&gt;&lt;br /&gt;
但是终于完成了，撒花～～～～&lt;/p&gt;

&lt;p&gt;最近看到，很久之前FreeBSD hackers在讨论做的一个内核层的http服务器，感觉挺有意思的。&lt;br /&gt;
然后打算能不能自己写一个。&lt;/p&gt;

&lt;p&gt;当然不是向过去的代码里添加https模块， &lt;br /&gt;
当然也不是一开始从头造轮子，做一个类似的。&lt;/p&gt;

&lt;p&gt;从一个简单的聊天服务器开始吧。&lt;br /&gt;
&lt;del&gt;几乎确定会写一点点，然后弃坑。&lt;/del&gt;&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;作为一只服务器&lt;/p&gt;

&lt;p&gt;第一步，需要接受信息，这里就需要从BSD的协议栈上，把原有的处理函数hook下来。&lt;/p&gt;

&lt;p&gt;这是一个很麻烦的事情。
hook下TCP UDP报文，判定需求的属性，然后根据报文不同的类型，采取不同的策略。&lt;br /&gt;
并决定是否将数据通入服务器函数内，或者交给原有函数，或者丢弃报文。&lt;/p&gt;

&lt;p&gt;总之，是一个几乎需要复制原有处理函数的工作。
还需要加上服务器处理函数。&lt;br /&gt;
&lt;del&gt;确定会弃坑&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;那么，先写一个ICMP的hook练手吧，毕竟时间挺晚了，明天还要上班。&lt;br /&gt;
好像和服务器没什么关系，并且也没打算一次写完。
所以打算看服务器应该怎么写的观众可以右上角了。&lt;/p&gt;

&lt;p&gt;既然是需要hook下协议处理函数，首先就是这个函数的注册方法。&lt;/p&gt;

&lt;p&gt;ICMP长这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    .pr_type =		SOCK_RAW,
    .pr_domain =		&amp;amp;inetdomain,
    .pr_protocol =		IPPROTO_ICMP,
    .pr_flags =		PR_ATOMIC|PR_ADDR|PR_LASTHDR,
    .pr_input =		icmp_input,
    .pr_ctloutput =		rip_ctloutput,
    .pr_usrreqs =		&amp;amp;rip_usrreqs
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TCP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    .pr_type =		SOCK_STREAM,
    .pr_domain =		&amp;amp;inetdomain,
    .pr_protocol =		IPPROTO_TCP,
    .pr_flags =		PR_CONNREQUIRED|PR_IMPLOPCL|PR_WANTRCVD,
    .pr_input =		tcp_input,
    .pr_ctlinput =		tcp_ctlinput,
    .pr_ctloutput =		tcp_ctloutput,
    .pr_init =		tcp_init,
    .pr_slowtimo =		tcp_slowtimo,
    .pr_drain =		tcp_drain,
    .pr_usrreqs =		&amp;amp;tcp_usrreqs
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;UDP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    .pr_type = 		SOCK_DGRAM,
    .pr_domain = 		&amp;amp;inetdomain,
    .pr_protocol = 		IPPROTO_UDP,
    .pr_flags = 		PR_ATOMIC|PR_ADDR,
    .pr_input = 		udp_input,
    .pr_ctlinput = 		udp_ctlinput,
    .pr_ctloutput = 	ip_ctloutput,
    .pr_init = 		udp_init,
    .pr_usrreqs = 		&amp;amp;udp_usrreqs
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，做出一个只会打印的函数函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void
icmp_input_hook(struct mbuf *m, int off)
{
    uprintf(&quot;hooked iemp\n&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再之后，把这个函数挂上去&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
ase MOD_LOAD:
	inetsw[ip_protox[IPPROTO_ICMP]].pr_input = icmp_input_hook;
	break;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，理论上所有的ICMP包就这样被截住了。&lt;br /&gt;
&lt;del&gt;一定会出问题&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;如果没弃坑，下次再补充ICMP递交回去多内容吧。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Jul 2018 08:49:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/13/SimpleKernelLevelServer1-2019/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/13/SimpleKernelLevelServer1-2019/</guid>
        
        <category>FreeBSD</category>
        
        <category>Kernel</category>
        
        <category>Server</category>
        
        
      </item>
    
      <item>
        <title>A simple try on FreeBSD rootkit</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近在忙着将防篡改软件移植到FreeBSD上。&lt;/p&gt;

&lt;p&gt;对比Linux，FreeBSD的内核版本较少，可以直接在内核层内做个拦截。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux如果这样做的话，需要一直适配内核版本，这个很麻烦，大致是这两种思路：&lt;/p&gt;

  &lt;p&gt;每个linux内核版本都编译适配一下，对不同的内核版本适用不同的ko，需要无意义的编译很多次；&lt;br /&gt;
对应不同的内核型号，产品在用户处条件编译，有各种风险。&lt;/p&gt;

  &lt;p&gt;据说也可以做一个系统无关的elf文件运行。但这个的实现看起来很麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看起来安全一些，不易被破坏。&lt;/p&gt;

&lt;p&gt;那么首先做一个监控open的hook吧&lt;/p&gt;

&lt;p&gt;参考这个 &lt;a href=&quot;http://www.cnblogs.com/bits/archive/2009/05/19/BSD_SYS_open_hook.html&quot;&gt;BSD下第一个syscall hook，监视SYS_open的情况&lt;/a&gt;&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;首先是一些系统调用有关的文件&lt;/p&gt;

&lt;p&gt;/usr/src/sys/kern/sys_generic.c&lt;br /&gt;
 /usr/src/sys/kern/vfs_syscalls.c&lt;br /&gt;
这两个有这次调用需要的sys_open的函数体&lt;/p&gt;

&lt;p&gt;/usr/src/sys/sys/syscall.h&lt;br /&gt;
这里是调用号&lt;/p&gt;

&lt;p&gt;首先，需要一个处理load的函数，类似这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int
load(struct module *module, int cmd, void *arg)
{
    int error = 0;
    switch (cmd) {
    case MOD_LOAD:
        uprintf(&quot;Hello, world!\n&quot;);
        break;
    case MOD_UNLOAD:
        uprintf(&quot;Good-bye, cruel world!\n&quot;);
        break;
    default:
        error = EOPNOTSUPP;
        break;
    }
    return(error);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;来自 Designing BSD Rootkits&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;据说，也可以省略注册处理函数这步,但是为了安全，还是加上更好&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Actually, this isn’t entirely true. You can have a KLD that just includes a sysctl. You can also dispense with module handlers if you wish and just use SYSINIT and SYSUNINIT directly to register functions to be invoked on load and unload, respectively. You can’t, however, indicate failure in those.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了load后使用自定义的open_hook代替普通的open，需要这样改进&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch (cmd) {
    case MOD_LOAD:
    sysent[SYS_open].sy_call = (sy_call_t *)open_hook;
    break;
    case MOD_UNLOAD:
    sysent[SYS_open].sy_call = (sy_call_t *)sys_open;
    break;
    default:
    error = EOPNOTSUPP;
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，在load的情况下，就会将SYS_open的处理函数变为open_hook了，卸载时自动恢复。&lt;/p&gt;

&lt;p&gt;然后，为了打印open的参数，需要这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* system call hook. */
static int
open_hook(struct thread *td, register struct open_args *uap)
{
// 输出 open 打开的文件到控制台
uprintf(&quot;  SYS_open: \&quot;%s\&quot;, flags: %d, mode: %X\n&quot;, uap-&amp;gt;path, uap-&amp;gt;flags, uap-&amp;gt;mode);

return (sys_open(td, uap));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，编译加载，大概这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ls .
SYS_open: &quot;.&quot;, flags: 1048576, mode: 0
SYS_open: &quot;.&quot;, flags: 1048576, mode: 0
SYS_open: &quot;.&quot;, flags: 1179652, mode: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可见新加入的组件已经开始工作了&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Jun 2018 00:36:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/21/SimpleFreeBSDRookit-2019/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/21/SimpleFreeBSDRookit-2019/</guid>
        
        <category>FreeBSD</category>
        
        
      </item>
    
  </channel>
</rss>
